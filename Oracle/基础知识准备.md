问题:

1. 有没有用过synchronized 
     在自己的项目里没用过，但是有了解 
2. 一个类中有3个方法a、b、c，都用synchronized修饰。问两个线程能不能同时访问这些方法.
    先确认这三个方法不是static，然后说如果访问的是同一个对象，那么就不能并行，否则可以。 
3. volatile作用是什么，为什么有了synchronized还需要volatile
    两个基本作用：1. 保证可见性 2. 禁止指令重排序优化。再展开扯一些blabla
    
java(例如string为啥immutable，stringbuilder原理?)，内存管理(例如gc的原理), 数据结构(HashMap的implementation，细节到java8里hashcode相同咋办,跟java5之前的比)
  
多线程(例如死锁的原理,concurrentHashMap vs HashTable)，数据库(例如join跟union,还有写sql)，网络(tcp/udp区别)
  
java和c#的各种知识，能想起来的就是，比如java的composite和inheritance，java和c#的语言比较，那些特征你喜欢，c#里面的aync，await用法，写出json的格式，javascript的==和===，c# generic，delegation，lambda的语法，还有很多语言知识问题。

过简历，比如问大数据排序如何做，aws lambda是如何实现的，各种排序算法的比较，TCP和UDP的比较

## final finally finalize
1. final:Final is used to apply restrictions on class, method and variable. Final class can't be inherited(extended), final method can't be overridden and final variable value can't be changed.
**final is a keyword**
2. finally:Finally is used to place important code, it will be executed whether exception is handled or not.
**finally is a block**
```
class FinallyExample{  
public static void main(String[] args){  
try{  
int x=300;  
}catch(Exception e){System.out.println(e);}  
finally{System.out.println("finally block is executed");}  
}}  
```
3. finalize: Finalize is used to perform clean up processing just before object is garbage collected.
**Finalize is a method.**
```
class FinalizeExample{  
public void finalize(){System.out.println("finalize called");}  
public static void main(String[] args){  
FinalizeExample f1=new FinalizeExample();  
FinalizeExample f2=new FinalizeExample();  
f1=null;  
f2=null;  
System.gc();  
}}  
```
## access modifier
 1. public 
 2. private 
 3. protected
 4. default(package private)
## non-acess modifier
they are used with classes, methods, variables, constructors etc to provide information about their behavior to JVM 
1. static: When a member is declared static, it can be accessed before any objects of its class are created, and without reference to any object. it includes static method, variable, block, class.
2. final
3. abstract
4. synchronized
5. transient
6. volatile
7. native

## java8新特性
1. hashmap chaining
2. anonymous class
3. stream

## why string immutable
https://www.baeldung.com/java-string-immutable

Immutable: This means that once the object has been assigned to a variable, we can neither update the reference nor mutate the internal state by any means.

The key benefits of keeping this class as immutable are caching, security, synchronization, and performance.

1. Caching the String literals and reusing them saves a lot of heap space because different String variables refer to the same object in the String pool.

Java String Pool is the special memory region where Strings are stored by the JVM. Since Strings are immutable in Java, the JVM optimizes the amount of memory allocated for them by storing only one copy of each literal String in the pool.

2. Security
If Strings were mutable, then by the time we execute the update, we can’t be sure that the String we received, even after performing security checks, would be safe. 

3. Synchronization
Being immutable automatically makes the String thread safe since they won’t be changed when accessed from multiple threads.

4. Hashing
the hashCode() method is overridden in String class to facilitate caching, such that the hash is calculated and cached during the first hashCode() call and the same value is returned ever since.

5. Performance
String pool exists because Strings are immutable. In turn, it enhances the performance by saving heap memory and faster access of hash implementations when operated with Strings.


## stringbuilder internal work
底层是 char array, 然后会有个counter记录长度. 如果超过默认长度 就double为两倍
 ```
 public AbstractStringBuilder append(String str) {
     if (str == null) str = "null";
     int len = str.length();
     if (len == 0) return this;
     int newCount = count + len;
     if (newCount > value.length)
         expandCapacity(newCount);

    str.getChars(0, len, value, count);
     count = newCount;
     return this;
 }
 void expandCapacity(int minimumCapacity) {
     int newCapacity = (value.length + 1) * 2;
     if (newCapacity <>
          newCapacity = Integer.MAX_VALUE;
     } else if (minimumCapacity > newCapacity) {
          newCapacity = minimumCapacity;
     }
     value = Arrays.copyOf(value, newCapacity);
 }
```
## interface and abstract class
