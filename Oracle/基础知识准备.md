问题:

1. 有没有用过synchronized 
     在自己的项目里没用过，但是有了解 
2. 一个类中有3个方法a、b、c，都用synchronized修饰。问两个线程能不能同时访问这些方法. 1point3acres
    先确认这三个方法不是static，然后说如果访问的是同一个对象，那么就不能并行，否则可以。 
3. volatile作用是什么，为什么有了synchronized还需要volatile
    两个基本作用：1. 保证可见性 2. 禁止指令重排序优化。再展开扯一些blabla
    
java(例如string为啥immutable，stringbuilder原理?)，内存管理(例如gc的原理), 数据结构(HashMap的implementation，细节到java8里hashcode相同咋办,跟java5之前的比)
  
多线程(例如死锁的原理,concurrentHashMap vs HashTable)，数据库(例如join跟union,还有写sql)，网络(tcp/udp区别)
  
java和c#的各种知识，能想起来的就是，比如java的composite和inheritance，java和c#的语言比较，那些特征你喜欢，c#里面的aync，await用法，写出json的格式，javascript的==和===，c# generic，delegation，lambda的语法，还有很多语言知识问题。

过简历，比如问大数据排序如何做，aws lambda是如何实现的，各种排序算法的比较，TCP和UDP的比较

## final finally finalize
1. final:Final is used to apply restrictions on class, method and variable. Final class can't be inherited(extended), final method can't be overridden and final variable value can't be changed.
**final is a keyword**
2. finally:Finally is used to place important code, it will be executed whether exception is handled or not.
**finally is a block**
```
class FinallyExample{  
public static void main(String[] args){  
try{  
int x=300;  
}catch(Exception e){System.out.println(e);}  
finally{System.out.println("finally block is executed");}  
}}  
```
3. finalize: Finalize is used to perform clean up processing just before object is garbage collected.
**Finalize is a method.**
```
class FinalizeExample{  
public void finalize(){System.out.println("finalize called");}  
public static void main(String[] args){  
FinalizeExample f1=new FinalizeExample();  
FinalizeExample f2=new FinalizeExample();  
f1=null;  
f2=null;  
System.gc();  
}}  
```
## access modifier
 1. public 
 2. private 
 3. protected
 4. default(package private)
## non-acess modifier
they are used with classes, methods, variables, constructors etc to provide information about their behavior to JVM 
1. static: When a member is declared static, it can be accessed before any objects of its class are created, and without reference to any object. 
2. final
3. abstract
4. synchronized
5. transient
6. volatile
7. native

## java8新特性
hashmap chaining
anonymous class
stream

## why string immutable

## stringbuilder internal work
底层是 char array, 然后会有个counter记录长度. 如果超过默认长度 就double为两倍
 ```
 public AbstractStringBuilder append(String str) {
     if (str == null) str = "null";
     int len = str.length();
     if (len == 0) return this;
     int newCount = count + len;
     if (newCount > value.length)
         expandCapacity(newCount);

    str.getChars(0, len, value, count);
     count = newCount;
     return this;
 }
 void expandCapacity(int minimumCapacity) {
     int newCapacity = (value.length + 1) * 2;
     if (newCapacity <>
          newCapacity = Integer.MAX_VALUE;
     } else if (minimumCapacity > newCapacity) {
          newCapacity = minimumCapacity;
     }
     value = Arrays.copyOf(value, newCapacity);
 }
```
